# lec6 SPOC思考题


NOTICE
- 有"w3l2"标记的题是助教要提交到学堂在线上的。
- 有"w3l2"和"spoc"标记的题是要求拿清华学分的同学要在实体课上完成，并按时提交到学生对应的git repo上。
- 有"hard"标记的题有一定难度，鼓励实现。
- 有"easy"标记的题很容易实现，鼓励实现。
- 有"midd"标记的题是一般水平，鼓励实现。

## 与视频相关思考题

### 6.1	非连续内存分配的需求背景
 1. 为什么要设计非连续内存分配机制？

    可以充分利用内存，减少碎片浪费的概率，也方便不同应用共享同一片内存。


 1. 非连续内存分配中内存分块大小有哪些可能的选择？大小与大小是否可变?

    大小可变。大块内存管理成本更低，小块内存更节约，更灵活。


 1. 为什么在大块时要设计大小可变，而在小块时要设计成固定大小？小块时的固定大小可以提供多种选择吗

    方便管理。节约管理分配内存时查表等的时间。

    如果大块小块都固定大小，不方便管理，这个大小很难在满足应用需要的同时节约内存。应该提供多种选择。

### 6.2	段式存储管理
 1. 什么是段、段基址和段内偏移？

    段是一段连续整体的内存，拥有相对独立的内容和存储数据的方式。

    每段的段基址是固定的，对顶层应用程序透明。段基址加上段内偏移构成真正的虚拟地址。

2. 段式存储管理机制的地址转换流程是什么？为什么在段式存储管理中，各段的存储位置可以不连续？这种做法有什么好处和麻烦？

   地址转换：先用段基址家段内偏移构成虚拟地址，再通过硬件构成物理地址。

   因为一段程序拥有唯一的一个段基址。程序不能跨段访问别的段，因此各段存储位置不需要连续。

   这样使得内存管理更加灵活，为每个段预留了足够的空间，但是增加了地址转换成本，每次寻址都需要增加一步计算。


### 6.3	页式存储管理
 1. 什么是页（page）、帧（frame）、页表（page table）、存储管理单元（MMU）、快表（TLB, Translation Lookaside Buffer）和高速缓存（cache）？

    在页式存储管理中，内存被划分成大小相同的页。每一页拥有一个固定的基址，寻址时加上偏移量。

    帧是堆栈中每个函数拥有的一段内存。除了局部变量，还存放调用者的程序位置，传递的参数等信息。

    页表是记录页分布情况的表，存放在内存中。用于将逻辑页号转换为物理页号，参与程序的虚实地址转换过程。

    存储管理单元是集成在CPU上的硬件功能单元，包括块表和片上高速缓存。

    块表是存放了页表中最近刚刚用到的几条表项。CPU在使用页表进行地址转换时会首先访问块表，而由于其存放在CPU上，使用硬件进行并行的对比，因此查找速度快很多，相应地，容量也小很多。

    高速缓存是CPU上的硬件单元，存放内存里的少量常用的代码片段和数据片段的复制，用于减少访存速度。

 1. 页式存储管理机制的地址转换流程是什么？为什么在页式存储管理中，各页的存储位置可以不连续？这种做法有什么好处和麻烦？

    首先通过虚拟地址获得虚拟页号和偏移量。这个页号会被送到TLB中查找，若命中则获得物理页号，若不命中则引发中断，去页表中查找。物理页号加上偏移量即为物理地址。

    页式存储方法的好处是管理内存更加灵活高效，便于共享，也便于抽象出足够大的虚拟内存。不过管理这种存储方式需要大量硬件支持，也会时常引发中断，增加OS的设计复杂度。


### 6.4	页表概述
 1. 每个页表项有些什么内容？有哪些标志位？它们起什么作用？

    页表项包括页号，进程数目和是否有效，是否被修改，读写权限的使能。参与虚实地址转换，方便进程管理。

 1. 页表大小受哪些因素影响？

    受虚拟空间大小，物理地址空间大小，页表大小的影响。


### 6.5	快表和多级页表
 1. 快表（TLB）与高速缓存（cache）有什么不同？

    块表只是页表常用的几项在CPU片上的复制。高速缓存是一段代码或数据的复制。

 1. 为什么快表中查找物理地址的速度非常快？它是如何实现的？为什么它的的容量很小？

    块表的查找是通过硬件比较电路实现的，所有表项都会同时进行比对，因此查找速度十分快，只有几个门延迟。由于实现它的硬件成本很高，因此它的容量很小。

 1. 什么是多级页表？多级页表中的地址转换流程是什么？多级页表有什么好处和麻烦？

    多级页表是为了解决一级页表占用空间过大采用的技术。地址空间被划分为大片作为第一级页面，在这个页面下再用一层页表进行查找，页表是用于查找第二级页表的索引，地址转换需要两次查表。好处是节省了页表空间，由于总的页表项数目减少了，页表占用的空间也减小了。但是增加了寻址的时间成本。


### 6.6	反置页表
 1. 页寄存器机制的地址转换流程是什么？

    页寄存器机制和页表机制相反，是用虚拟地址和进程号hash值去查找页寄存器以完成地址转换。

 1. 反置页表机制的地址转换流程是什么？

    虚拟地址和进程号hash值去查找页寄存器以完成地址转换。

 1. 反置页表项有些什么内容？

    PID、逻辑页号、标志位（是否存在，是否被读写，读写权限）

### 6.7	段页式存储管理
 1. 段页式存储管理机制的地址转换流程是什么？这种做法有什么好处和麻烦？

 1. 如何实现基于段式存储管理的内存共享？

 1. 如何实现基于页式存储管理的内存共享？

## 个人思考题
（1） (w3l2) 请简要分析64bit CPU体系结构下的分页机制是如何实现的



## 小组思考题
（1）(spoc) 某系统使用请求分页存储管理，若页在内存中，满足一个内存请求需要150ns (10^-9s)。若缺页率是10%，为使有效访问时间达到0.5us(10^-6s),求不在内存的页面的平均访问时间。请给出计算步骤。



（2）(spoc) 有一台假想的计算机，页大小（page size）为32 Bytes，支持32KB的虚拟地址空间（virtual address space）,有4KB的物理内存空间（physical memory），采用二级页表，一个页目录项（page directory entry ，PDE）大小为1 Byte,一个页表项（page-table entries
PTEs）大小为1 Byte，1个页目录表大小为32 Bytes，1个页表大小为32 Bytes。页目录基址寄存器（page directory base register，PDBR）保存了页目录表的物理地址（按页对齐）。

PTE格式（8 bit） :
```
  VALID | PFN6 ... PFN0
```
PDE格式（8 bit） :
```
  VALID | PT6 ... PT0
```
其
```
VALID==1表示，表示映射存在；VALID==0表示，表示映射不存在。
PFN6..0:页帧号
PT6..0:页表的物理基址>>5
```
在[物理内存模拟数据文件](./03-2-spoc-testdata.md)中，给出了4KB物理内存空间的值，请回答下列虚地址是否有合法对应的物理内存，请给出对应的pde index, pde contents, pte index, pte contents。
```
1) Virtual Address 6c74
   Virtual Address 6b22
2) Virtual Address 03df
   Virtual Address 69dc
3) Virtual Address 317a
   Virtual Address 4546
4) Virtual Address 2c03
   Virtual Address 7fd7
5) Virtual Address 390e
   Virtual Address 748b
```

比如答案可以如下表示： (注意：下面的结果是错的，你需要关注的是如何表示)
```
Virtual Address 7570:
  --> pde index:0x1d  pde contents:(valid 1, pfn 0x33)
    --> pte index:0xb  pte contents:(valid 0, pfn 0x7f)
      --> Fault (page table entry not valid)

Virtual Address 21e1:
  --> pde index:0x8  pde contents:(valid 0, pfn 0x7f)
      --> Fault (page directory entry not valid)

Virtual Address 7268:
  --> pde index:0x1c  pde contents:(valid 1, pfn 0x5e)
    --> pte index:0x13  pte contents:(valid 1, pfn 0x65)
      --> Translates to Physical Address 0xca8 --> Value: 16
```

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，请说明原因。

（3）请基于你对原理课二级页表的理解，并参考Lab2建页表的过程，设计一个应用程序（可基于python、ruby、C、C++、LISP、JavaScript等）可模拟实现(2)题中描述的抽象OS，可正确完成二级页表转换。

[链接](https://piazza.com/class/i5j09fnsl7k5x0?cid=664)有上面链接的参考答案。请比较你的结果与参考答案是否一致。如果不一致，提交你的实现，并说明区别。

（4）假设你有一台支持[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)的机器，请问你如何设计操作系统支持这种类型计算机？请给出设计方案。

 (5)[X86的页面结构](http://os.cs.tsinghua.edu.cn/oscourse/OS2019spring/lecture06)
---

## 扩展思考题

阅读64bit IBM Powerpc CPU架构是如何实现[反置页表](http://en.wikipedia.org/wiki/Page_table#Inverted_page_table)，给出分析报告。


## interactive　understand VM

[Virtual Memory with 256 Bytes of RAM](http://blog.robertelder.org/virtual-memory-with-256-bytes-of-ram/)：这是一个只有256字节内存的一个极小计算机系统。按作者的[特征描述](https://github.com/RobertElderSoftware/recc#what-can-this-project-do)，它具备如下的功能。
 - CPU的实现代码不多于500行；
 - 支持14条指令、进程切换、虚拟存储和中断；
 - 用C实现了一个小的操作系统微内核可以在这个CPU上正常运行；
 - 实现了一个ANSI C89编译器，可生成在该CPU上运行代码；
 - 该编译器支持链接功能；
 - 用C89, Python, Java, Javascript这4种语言实现了该CPU的模拟器；
 - 支持交叉编译；
 - 所有这些只依赖标准C库。

针对op-cpu的特征描述，请同学们通过代码阅读和执行对自己有兴趣的部分进行分析，给出你的分析结果和评价。
